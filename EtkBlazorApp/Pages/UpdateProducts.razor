@page "/update-products"
@attribute [Authorize(Roles = "Administrator, Manager")]

<h3>Обновление цен и остатков</h3>

@if (accounts == null)
{
    <LoadingSpinner />
}
else
{
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-2">
                <button class="btn btn-success btn-lg" @onclick="UpdateSelectedAccountProducts" disabled="@IsUpdateButtonDisabled">Обновить</button>
            </div>
            <div class="col-md-2">
                <span><input type="checkbox" @bind-value="@clearStockBeforeUpdate" /> &nbsp;&nbsp;Обнулять остатки</span>
            </div>

            <AuthorizeView Roles="Administrator">
                <Authorized>
                    <div class="col-md-2 offset-6" style="text-align: right;">
                        <a href="/shop-account/new" class="btn btn-sm btn-success">Добавить новый</a>
                    </div>
                </Authorized>
            </AuthorizeView>
        </div>
    </div>

    <hr style="margin: 10px 5px;"/>

    <div class="container-fluid" >
        @foreach (var account in accounts)
        {
            <ShopAccountComponent ShopAccount="@account"
                                  OnChecked="@(() => StateHasChanged())"
                                  OnAccountDeleted="@(() => accounts.Remove(account))" />
        }
    </div>

}

@code {
    bool clearStockBeforeUpdate;

    List<ShopAccountViewModel> accounts = null;
    ShopAccountViewModel accountToDelete = null;

    [Inject] PriceListManager priceListManager { get; set; }
    [Inject] DatabaseManager databaseManager { get; set; }
    [Inject] ReportManager reportManager { get; set; }
    [Inject] IDatabaseProductCorrelator correlator { get; set; }
    [Inject] IToastService toastService { get; set; }

    public bool IsUpdateButtonDisabled
    {
        get
        {
            bool hasSelectedItemAndUploadedPriceList = accounts.Any(ac => ac.IsSelected) && priceListManager.PriceLines.Any();
            return (accounts == null || priceListManager.PriceLines.Count == 0) ? true : !hasSelectedItemAndUploadedPriceList;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        accounts = (await databaseManager.GetMonobrandAccountConnections()).Select(account => new ShopAccountViewModel()
        {
            Title = account.title,
            Id = account.website_id,
            Uri = account.uri,
            DB_Host = account.db_host,
            DB_Login = account.db_login,
            DB_Password = account.db_password,
            FTP_Host = account.ftp_host,
            FTP_Login = account.ftp_login,
            FTP_Password = account.ftp_password
        }).ToList();
    }

    private async Task UpdateSelectedAccountProducts()
    {
        var checkedAccounts = accounts.Where(ac => ac.IsSelected).ToList();

        foreach (var account in checkedAccounts)
        {
            await UpdateAccountProducts(account);
        }
    }

    private async Task UpdateAccountProducts(ShopAccountViewModel account)
    {
        account.ActivateProgressBar();

        try
        {
            var products = await databaseManager.ReadProducts(account.Id);
            var updateData = await correlator.GetCorrelationData(products, priceListManager.PriceLines);
            reportManager.WebsiteUpdatedData.Info[account.Id] = updateData;

            await databaseManager.Update(account.Id, updateData, clearStockBeforeUpdate);

            toastService.ShowError($"Сайт [{account.Uri}] обновлен ({updateData.Count}) товара(ов)", "Информация");
        }
        catch (Exception ex)
        {
            Log.Logger.Error($"Ошибка загрузки прайс листа для аккаунта: [{account.Title}] " + ex.Message);
            toastService.ShowError($"При обновлении данных [{account.Uri}] произошла ошибка", "Ошибка обновления");
        }
        finally
        {
            account.DeactivateProgressBar();
        }
    }
}
